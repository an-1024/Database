# MySQL 概述
MySQL 数据库是一款关系型数据库。目前中小型企业，甚至大型企业都在使用。

## 关系型数据库的定义：
关系型数据库是信息的集合，它以预定义的关系组织数据，数据存储在一个或多个由列和行构成的表（或“关系”）中，用户可以轻松查看和理解不同数据结
构之间的关系。关系是不同表之间的逻辑连接，根据这些表之间的交互建立。

典型的代表有：SQL Server，Oracle,Mysql,PostgreSQL。

### 关系型数据库优点：
1. 容易理解，二维表的结构非常贴近现实世界，二维表格，容易理解。 
2. 使用方便，通用的sql语句使得操作关系型数据库非常方便。 
3. 易于维护，数据库的ACID属性，大大降低了数据冗余和数据不一致的概率。
### ACID
原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）

### 关系型数据库缺点：
1. 海量数据的读写效率: 对于网站的并发量高，往往达到每秒上万次的请求，对于传统关系型数据库来说，硬盘I/o是一个很大的挑战。
2. 高扩展性和可用性: 在基于web的结构中，数据库是最难以横向拓展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库没有办法像
web Server那样简单的通过添加更多的硬件和服务节点来拓展性能和负载能力

## 非关系型数据库
非关系数据库不以表格式存储和组织数据。不同数据点之间没有表、行、列或关系。 相反，数据存储在集合中。数据库通常是非结构化的并使用动态架构。

典型的代表有：MongoDB，Redis、CouchDB；

### 非关系型数据库优点
1. 无需经过sql层的解析，读写性能很高； 
2. 基于键值对，数据没有耦合性，容易扩展； 
3. 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。

### 非关系型数据库缺点
1. 不提供sql支持，学习和使用成本较高； 
2. 无事务处理，附加功能bi和报表等支持也不好；

# MySQL 索引
索引的定义：索引是帮助 MySQL 高效获取数据的**排好序**的数据结构

常见的索引数据结构：
1. 二叉树：
2. 红黑树：
3. Hash 表：
4. B-Tree

在了解索引之前，首先我们需要了解在计算机中数据是怎么存储的。

## 计算机的存储结构
1. 寄存器和cpu速度相当，空间比较小在kb级别。      
2. 高速缓存比寄存器要慢1倍左右，但是空间可以达到MB级别。
3. 内存比缓存要慢10倍左右，但是空间可以达到GB级别，当前个人电脑一般都不小于4G
4. 硬盘这个速度更慢，比内存要慢上万被，千万被级别，但是价格也比较偏移，空间也很大。
5. 其他存储光盘，软盘，usb外接的其他存储器，作为硬盘的一个补充，有便于携带的优点

类似一个金字塔结构：
![1.计算机存储结构](../photo/1.计算机存储结构.png)

## 磁盘存储原理
磁盘是计算机存储系统、数据、文件等信息的硬件。磁盘主要由碟片、磁头、电机马达、接口和控制电路控制芯片组成。
主要了解一下：磁头，磁道，扇区，柱面 概念即可。

1. 磁头（head）：不用说，主要就是读取磁盘表面磁方向和改变其方向，每个盘面有一个磁头，它极其贴近地悬浮在盘面上，但是绝对不与盘面接触，否则会损坏磁头和盘面；
2. 磁道（track）：磁道是单个盘面上的同心圆，当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道，
一个盘面上的磁道可以有成千上万个。相邻磁道之间并不是紧挨着的，这是因为磁化单元相隔太近时磁性会产生相互影响，同时也为磁头的读写带来困难。
3. 柱面（cylinder）：在由多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面。
4. 扇区（sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。硬盘的第一个扇区，叫做引导扇区。扇区是被间隙
（gap）分割的圆的片段，间隙未被磁化成0或者1。注意，扇区是读写磁盘最基本的单位，如果一个扇区因为某种原因被破坏，那么整个扇区的数据都会受影响。

由上面的定义我们可以知道，数据的存放最终是存放在了扇区中，因此，数据的存放在磁盘上可能并不连续。因此，在操作系统从磁盘上读取数据时，会经历如
下步骤：
1. 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区;
2. 为了读取这个扇区的数据，需要将磁头放到这个扇区上方: 
   1. 首先必须找到柱面，即磁头需要移动对准相应磁道，这个过程叫做寻道或定位；
   2. 盘面确定以后，盘片开始旋转，将目标扇区旋转到磁头下;

总结一下就是：
即一次访盘请求（读/写）完成过程由三个动作组成：
1. 寻道（时间）：磁头移动定位到指定磁道，这部分时间代价最高，最大可达到0.1s左右； 
2. 旋转延迟（时间）：等待指定扇区旋转至磁头下。与硬盘自身性能有关，xxxx转/分； 
3. 数据传输（时间）：数据通过系统总线从磁盘传送到内存的时间，一般传输一个字节大概0.02us。

通常我们将这个(读/写)过程称之为对磁盘的一次 I/O 操作。为了减少 I/O 次数，提高查询效率，因此引入了**索引**。

举个例子，想象一下，现在有一本500页厚包含几十万字的字典，同时里面的字是无序排列的，现在我需要你从中找出某几个字出来同时不允许查看目录。毫无疑问，我们只能一页一页的翻，这是非人类能接受的工作，我们必然想的是先看目录，找到相关的字或者偏旁，然后去对应的地方查找文字，这样效率就大大提高了。目录事实上就是一种索引，其思想一脉相承。
数据库的索引类似于书中的这个目录。索引会帮助我们快速检索数据库，查询不需要通过整个表来获取数据，而是从索引中找到数据块。

## 例子
先说一下 MySQL 底层数据结构并没有使用前面提到过的几种数据结构。我们通过下面这个例子分析一下：如图：
![2.索引示例](../photo/2.索引示例.png)
### 二叉树存储
当我们将上述数据按照二叉树的数据结构存放，看一下是二叉树是如何构建的：
![3.二叉树构建](../photo/3.二叉树构建.png)
可以发现二叉树成了链式结构，当我们要查找 50 这个数据，会按照类似链遍的形式遍历所有数据，在第 5 次找到我们想要的数据。
这就相当于操作了 5 次 I/O，对于这种单边增长的数据，并没有提升查询效率。
### 红黑树
红黑树的构建图：
![4.红黑树构建](../photo/4.红黑树构建.png)
相对于二叉树的存储，红黑树具有自平衡的特点：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，相比于二叉树在查询性能上有了进一步的提升。
但是红黑树仍然有自己的局限性，当数据量很大的情况下，红黑树存放的数据越多，那么必然会导致一个问题，那就是红黑树的高度增加，高度增加就意味着
I/O 次数的增多，查询效率就会下降。红黑树可以在 O(log n) 时间内做查找、插入和删除，这里 n 是树中元素数目。当 n 越大，时间复杂度是呈线性增长的。
### B-Tree (B 树)
根据上述两个数据结构来看，树的结构确实能带来查询性能的优化，但是随着数据量的增加，树的的高度就会增加，进而影响查询效率。所以需要我们一方面
控制树的高度，另一方面要进可能的多存数据。针对于这种特性，B-Tree 的数据结构诞生了。

B树中每一个内部节点会包含一定数量的键，键将节点的子树分开。例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键： a1 和 a2 。
左边子树的所有值都必须小于 a1 ，中间子树的所有值都必须在 a1 和a2 之间，右边子树的所有值都必须大于 a2 。数据存储结构如下图(额外增加了许多数据)：
![5.B-Tree构建](../photo/5.B-Tree构建.png)
但是 MySQL 底层的索引结构仍然没有使用 B-Tree。这是因为在 B-Tree 的叶子节点中除了关键字、指针、还包含除关键字外的其他信息。前面提到过，
数据会存放到磁盘的扇区上，每个扇区的 大小是固定的，当你横向的数据较大，那么就意味这横向存放的数据索引变小，纵向就要变长即树的高度增加，
也就意味查询数据的 I/O 次数增加，导致查询效率下降。可以计算一下：

Innodb 的存储是以 page 为单位，一页大小默认是 16384 个字节即 16 KB。我们一般以主键作为索引，bigint 在MySQl 中占 8 个字节；
指针占 6 个字节，正常情况下，额外的数据记录不会超过 1 KB，所以 16384/1024 等于 16 个叶子节点大小，每个节点代表一条数据记录，那么一个高度
为 2 的 B-Tree 只能存放 16 * 16 = 256 条记录；当存放千万级别的数据的时候，B-Tree 的高度可想而知。

### B+ 树
上面分析了 B-Tree 的缺点之后，我们知道是因为节点存储了额外的信息导致每页可放的节点数变少，即横向变短。那么我们可以将额外的数据信息放到
叶子节点中，非叶子节点只存放关键字、指针信息，这样虽然会造成关键字、索引冗余，但是数据的存放量却大大提升了。如下图是存放了 10～180 的 B+
的数据结构图：
![6.B+构建](../photo/6.B+构建.png)
可以看到所有的数据信息都存放到最下面的叶子节点中。且是按照顺序排列。同样按照上述的例子计算：16384/14 = 1170；每页可以存放 1170 个节点；
当 B+ 树的高度为 1 的时候，可以存放 1170 * 16 = 18720，高度为 3， 18720 * 1170 = 21902400 三层可以存放 2 千多万数据。而且只需要三次
I/O。这效率绝对刚刚的。

# 存储引擎
聚簇索引：表数据文件本身就是按 B+Tree 组织的一个索引结构文件；叶子节点包含了完整的数据记录；Innodb 就是使用的聚簇索引
非聚簇索引：叶子节点仍然是索引文件，只是这个索引文件中包含指向对应数据块的指针：MyISAM 存储引擎。数据文件和索引文件分成两个文件

一个面试题：为什么 Innodb 表推荐创建表建立主键并且设置为整形且自增：
1. 建立主键：Innodb表数据文件是由 B+Tree 构成的索引结构文件，主键 id 自带索引，构建表的时候可以直接使用主键 id 进行构建。如果我们不建立主键 id 的话，
Innodb 在构建数据存储文件的时候会挑选一列没有重复的数据作为唯一标识开始构建，如果没有找到这样的数据列，那么 Innodb 会自动创建一个隐藏列
来构建表数据文件。通常来说，数据库这么宝贵的资源，不应该让它去处理这些无意义的逻辑。
2. 设置为整形：其次整形在 Innodb 中占用空间较小，查找比较的时候，整形比 UUID或者字符串比较，效率较高；
3. 自增：涉及到的问题比较多。
4. 为什么非主键索引结构叶子节点存储的是主键值：节省存储空间。因为当一个表里有很多索引的时候，如果每个索引树存储了具体的数据，会导致数据冗余，
造成磁盘空间的浪费。相比于根据索引查找到主键id，在根据主键id的索引树查询数据，虽然牺牲了性能，但是对于空间节省的成本来说，还是可以接受的。
## 为什么推荐使用整形自增主键
在 Innodb 中，索引不仅仅有 B+Tree，还有 Hash 结构。在存储索引的时候对关键字(key)进行一次 Hash 计算，就可以计算出数据将要存放的位置，
反而要比 B+Tree 高效。 但是 Hash 有一个比较严重的问题是：**这种方式适用于每次精准查询，对于范围查询就完蛋了。在实际的应用场景中，不可能所有的
查询都是精准查询**，另一方面是 Hash 自身存在的缺陷，Hash 冲突。因此才没有使用 Hash 结构存储索引以及数据。

## B+Tree 树的范围查询
那么 B+Tree 是如何实现范围查找：前面我们有一张 B+Tree 的数据结构图，在最底层的叶子节点中，叶子节之间是通过指针连接且有序。当我门进行范围
查找的时候，通过索引定位到具体数据，然后通过叶子节点之间的指针找出其他数据。所以叶子节点之间指针的意义在于支撑数据范围查找。这也是针对于 B-Tree
的另一个优化(注意：叶子节点之间是双向指针，不是单向，只是网页构建是单向的)。B-Tree 叶子节点之间并没有指针，范围查找仍然需要重新索引查找。

那么接下来看下为什么要用自增的主键：先看下如果没使用自增的主键，B+Tree 的结构是怎么样的：
![7.B+Tree 主键无序](../photo/7.B+Tree主键无序.png)
当主键无序的时候，当节点已经放满元素，在构建 B+Tree 的时候，B+Tree 会经历三个步骤：
1. 重新分裂节点；
2. 在开辟新的节点放入新的元素；
3. 重新平衡 B+Tree；

而对于主键自增有序的时候，当节点已经放满元素，B+Tree 会经历两个步骤：
1. 开辟新节点存放元素;
2. 重新平衡 B+Tree；

要知道在 MySQL 存储数据是按照页存储的，当我们向一个快写满的页中插入数据，B+Tree 为了保证所以有序，会重新申请数据页，并移动部分数据。大量
的数据移动会降低数据的插入效率。所以 Innodb 才会推荐使用自增主键。

## 联合(复合)索引的底层存储结构
下图摘自《高性能MySQL 第三版》：
![8.联合(复合)索引存储结构.png](../photo/8.联合(复合)索引存储结构.png)
和主键索引存储结构类似，不同的是索引节点中的索引是多个关键字的组合。就如途中所示：创建了一个联合主键索引：将 last_name、first_name、dob 
三列组成联合索引，那么索引中就包含了这三列的字段。索引顺序是按照创建表的时候指定的列的顺序排列。当我们根据索引查询一定会根据索引 last_name、
接着是 first_name 最后是  dob 的顺序来查询，也就是所谓的**最左匹配前缀原则**。

如果不是主键索引，当 last_name、first_name、dob 索引都相同的时候，会根据主键索引树再次**回表**查询。

有了上面的最左前缀配原则，我们就可以解释为什么联合索引会失效：首先我们一定要明确，索引的快速查找是建立在**有序**的情况下。因此我们就可以得出
当我们使用联合索引查询，一旦没有按照联合索引的顺序进行查找，而是眺开第一列，那么这条 SQL 语句就不会走索引。这就是因为 last_name、first_name、dob 
在构建好索引成为一个节点的时候，在整个数据表中**他们就是有序的(按照索引定义的顺序进行排列 last_name、first_name、dob)**，
如果单独使用 first_name或者dob作为条件查询，这两个数据整个数据表中并**不一定有序**， 所以不会走索引。

# Explain 详解与索引实践
创建几张测试表
```sql
-- EXPLAIN 测试
create table `actor_explain`(
                               `id` int(11) not null auto_increment,
                               `name` varchar(45) default null comment '名字',
                               `update_time` datetime default null,
                               primary key(`id`)
)ENGINE=Innodb comment='Explain 学习创建的 actor 表'

create table `film_explain`(
                              `id` int(11) not null auto_increment,
                              `name` varchar(20) default null,
                              primary key (`id`),
                              key `idx_name` (`name`) using btree
)ENGINE=Innodb comment='Explain 学习创建的 film 表'

create table `film_actor_explain`(
                                    `id` int(11) not null auto_increment,
                                    `film_id` int(11) not null,
                                    `actor_id` int(11) not  null,
                                    `remark` varchar(255) default null,
                                    primary key(`id`),
                                    key `idx_film_actor_id` (`film_id`, `actor_id`)
)ENGINE=Innodb comment='Exolain 学习创建的 film_actor 表'
```

插入数据
````sql
-- 插入测试数据
insert into `actor_explain`(`name`, `update_time`) values ('弗里曼', '1994-10-14');
insert into `actor_explain`(`name`, `update_time`) values ('泰隆·鲍华', '1957-12-17');
insert into `actor_explain`(`name`, `update_time`) values ('玛莎', '2016-03-15');
insert into `actor_explain`(`name`, `update_time`) values ('安·德鲁扬', '2014-03-09');
insert into `actor_explain`(`name`, `update_time`) values ('沃爾克·布魯赫', '2014-03-09');

insert into `film_explain`(`name`) values ('肖申克的救赎');
insert into `film_explain`(`name`) values ('控方证人');
insert into `film_explain`(`name`) values ('玛莎与熊');
insert into `film_explain`(`name`) values ('宇宙时空之旅');
insert into `film_explain`(`name`) values ('我们的父辈');

insert into `film_actor_explain` (`film_id`, `actor_id`) values (1,1)
insert into `film_actor_explain` (`film_id`, `actor_id`) values (2,2)
insert into `film_actor_explain` (`film_id`, `actor_id`) values (3,3)
insert into `film_actor_explain` (`film_id`, `actor_id`) values (4,4)
insert into `film_actor_explain` (`film_id`, `actor_id`) values (5,5)
````
## 数据查询
```sql
explain select * from actor_explain;
```
结果如下：
![Explain查询结果图](../photo/9.Explain查询结果图.png)
解释一下每列表示的意义：

| 列名            | 意义                                                                                                                                        | 每列包含的值                | 每个值代表的具体意义                                                                                                                                          |
|---------------|-------------------------------------------------------------------------------------------------------------------------------------------|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| id            | select 标识。序列号越大表示越先执行。序列号相同                                                                                                               |
| select_type   | 表示对应行是简单查询还是复杂查询。                                                                                                                         | SIMPLE                | 表示查询是简单查询：不包含子查询和union                                                                                                                              |
|               |                                                                                                                                           | PRIMARY               | 查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY                                                                                                                |
|               |                                                                                                                                           | UNION                 | UNION中的第二个或后面的SELECT语句                                                                                                                              |
|               |                                                                                                                                           | DEPENDENT UNION       | UNION中的第二个或后面的SELECT语句，取决于外面的查询                                                                                                                     |
|               |                                                                                                                                           | UNION RESULT          | UNION的结果                                                                                                                                            |
|               |                                                                                                                                           | SUBQUERY	             | 子查询中的第一个SELECT                                                                                                                                      |
|               |                                                                                                                                           | DEPENDENT SUBQUERY		  | 子查询中的第一个SELECT, 取决于外面的查询                                                                                                                            |
|               |                                                                                                                                           | DERIVED	              | 衍生表(FROM子句中的子查询)                                                                                                                                    |
|               |                                                                                                                                           | MATERIALIZED	         | 物化子查询                                                                                                                                               |
|               |                                                                                                                                           | MATERIALIZED	         | 物化子查询                                                                                                                                               |
|               |                                                                                                                                           | UNCACHEABLE SUBQUERY	 | 结果集无法缓存的子查询，必须重新评估外部查询的每一行                                                                                                                          |
|               |                                                                                                                                           | UNCACHEABLE UNION		   | UNION中第二个或之后的SELECT，属于无法缓存的子查询                                                                                                                      |
| table         | 表名(不一定是实际的表名)                                                                                                                             | <unionM,N>		          | 引用id为M和N UNION后的结果。                                                                                                                                 |
|               |                                                                                                                                           | `<derivedN>`	   	     | 引用id为N的结果派生出的表。派生表可以是一个结果集，例如派生自FROM中子查询的结果。                                                                                                        |
|               |                                                                                                                                           | `<subqueryN>`         | 引用id为N的子查询结果物化得到的表。即生成一个临时表保存子查询的结果。                                                                                                                |
| type(重要的列)    | 显示查询使用了何种类型，即决定了 MySQL 如何查找表中的行，查找数据记录的大概范围。从最好到最差的连接类型依次为(列出比较常见的类型)：system>const>eq_ref>ref>rang>index>ALL 一般我们要求保证查询达到 range 级别，最好达到 ref | system	               | 表中只有一行数据或者是空表，这是const类型的一个特例。且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index                                                              |
|               |                                                                                                                                           | const	                | 最多只有一行记录匹配。当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描                                                                                       |
|               |                                                                                                                                           | eq_ref	               | 多表join时，对于来自前面表的每一行，在当前表中只能找到一行。这可能是除了system和const之外最好的类型。当主键或唯一非NULL索引的所有字段都被用作join联接时会使用此类型                                                       |
|               |                                                                                                                                           | ref	                  | 对于来自前面表的每一行，在此表的索引中可以匹配到多行。若联接只用到索引的最左前缀或索引不是主键或唯一索引时，使用ref类型（也就是说，此联接能够匹配多行记录）。ref可用于使用'='或'<=>'操作符作比较的索引列                                         |
|               |                                                                                                                                           | range	                | 索引范围查询，常见于使用 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN()或者like等运算符的查询中                                                                         |
|               |                                                                                                                                           | index	                | 索引全表扫描，把索引从头到尾扫一遍。这里包含两种情况：一种是查询使用了覆盖索引，那么它只需要扫描索引就可以获得数据，这个效率要比全表扫描要快，因为索引通常比数据表小，而且还能避免二次查询。在extra中显示Using index，反之，如果在索引上进行全表扫描，没有Using index的提示 |
|               |                                                                                                                                           | all	                  | 全表扫描，性能最差                                                                                                                                           |
| possible_keys | 查询可能使用到的索引都会在这里列出来                                                                                                                                          | 	                     |                                                                                                                                                     |
| key           | 查询真正使用到的索引。select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。                                                                                                                                          | 	                     |                                                                                                                                                     |
| key_len       | 查询用到的索引长度（字节数）。如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，用多少算多少 |
| ref           | 如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func |
| rows          | 这是mysql估算的需要扫描的行数（不是精确值）。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好 |
| extra         | EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容 | distinct              | 在select部分使用了distinc关键字                                                                                                                              |
|               |  | Using filesort        | 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.                                     |                                    |
|               |  | Using index           | "覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件                                                                                                              |
|               |  | Using where           | 使用 where 语句来处理异常，并且查询的列未被索引覆盖                                                                                                                       |
|               |  | Using index condition | 查询的列没有被索引完全覆盖，where 条件中是一个前导列的范围                                                                                                                    |
|               |  | Using temporary | 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化。                                                                                                    |

测试 const、system
```sql
-- 关闭 MySQL优化器
set session optimizer_switch = 'derived_merge=off';
explain extended select * from (select * from film_explain where id = 1) tmp;
输出结果：
1	PRIMARY	<derived2>		system					1	100.00	
2	DERIVED	film_explain		const	PRIMARY	PRIMARY	4	const	1	100.00	
根据结果分析，常量查询，数据表中只有一个匹配行，查询类型是 const。而当表里只有一条数据记录，查询类型是 system

在上述 sql 后面再加一个 show warnings; 可以看到这条语句被解释为：
Warning	1681	'EXTENDED' is deprecated and will be removed in a future release.
Note	1003	/* select#1 */ select '1' AS `id`,'肖申克的救赎' AS `name` from dual

可以看到就是一个常量查询了。
```

测试 eq_ref
```sql
explain select * from film_actor_explain fae left join film_explain fe on fae.film_id = fe.id;

输出结果
1	SIMPLE	fae		ALL					5	100.00	
1	SIMPLE	fe		eq_ref	PRIMARY	PRIMARY	4	dev_server01_data.fae.film_id	1	100.00	
```

测试 ref
```sql
-- 简单 select 查询
explain select * from film_explain where `name` = '肖申克的救赎';
输出结果
1	SIMPLE	film_explain		ref	idx_name	idx_name	63	const	1	100.00	Using index

-- 关联表查询
explain select film_id from film_explain fe left join film_actor_explain fae on fe.id = fae.film_id;
输出结果：
1	SIMPLE	fe		index		idx_name	63		5	100.00	Using index
1	SIMPLE	fae		ref	idx_film_actor_id	idx_film_actor_id	4	dev_server01_data.fe.id	1	100.00	Using index
```

测试range
```sql
# 测试range 使用一个索引来检索给定范围的行
explain select * from actor_explain where id > 1;
-- 输出结果
1	SIMPLE	actor_explain		range	PRIMARY	PRIMARY	4		4	100.00	Using where
```
测试 index
```sql
explain select * from film_explain;
-- 输出结果
1	SIMPLE	film_explain		index		idx_name	63		5	100.00	Using index
根据结果分析，查询通过普通索引进行查找，而没有通过主键索引。原因后面解释。
```
测试 all
```sql
explain select * from actor_explain;
-- 输出结果
1	SIMPLE	actor_explain		ALL					5	100.00	
```

测试 Using temporary
```sql
explain select distinct `name` from actor_explain; 
输出结果
1	SIMPLE	actor_explain		ALL					5	100.00	Using temporary
```

测试 Using index
```sql
explain select distinct `name` from film_explain; 
输出结果：
1	SIMPLE	film_explain		index	idx_name	idx_name	63		5	100.00	Using index
```
## 索引实践
创建表，并添加数据
```sql
create table `employees_explain`(
	`id` int(11) not null auto_increment,
	`name` varchar(24) not null default '' comment '姓名',
	`age` int(11) not null default '0' comment '年龄',
	`position` varchar(20) not null default '' comment '职位',
	`hire_time` timestamp not null default current_timestamp comment '入职时间',
	primary key (`id`),
	key `idx_name_age_position` (`name`, `age`, `position`) using btree
)ENGINE=Innodb comment='学习索引实践的表 Explain-员工记录表'

insert into `employees_explain` (`name`, `age`, `position`, `hire_time`) values ('DirenJie', 22, 'manager', NOW());
insert into `employees_explain` (`name`, `age`, `position`, `hire_time`) values ('LiYunaFang', 23, 'dev', NOW());
insert into `employees_explain` (`name`, `age`, `position`, `hire_time`) values ('ChengYaoJin', 27, 'product manager', NOW());
```











