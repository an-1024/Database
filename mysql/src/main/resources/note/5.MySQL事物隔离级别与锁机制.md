# MySQL 事物隔离级别与锁机制
数据库操作都涉及并发执行多个事物，并发操作就会带来问题，这些问题包括：脏写、脏读、不可重复读、幻读。为了解决这些问题，数据库设计了
事物隔离机制、锁机制、MVCC 多版本并发控制隔离机制。通过这一套机制来解决多事物并发问题。
# 事物及其 ACID 属性
1. 原子性(Atomicity)： 事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。
2. 一致性(Consistent)： 在事务开始和完成时,数据都必须保持一致状态。 这意味着所有相关的数据规 则都必须应用于事务的修改,以保持数据的完整性。 
3. 隔离性(Isolation)： 数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独 立” 环境执行。 这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。 
4. 持久性(Durable)： 事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。
# 脏写(更新丢失)
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。
# 脏读（Dirty Reads）
一个事务正在对一条记录做修改， 在这个事务完成并提交前， 这条记录的数据就处于不一致的状态； 这时，另一个事务也来读取同一条记录，如果不加控制， 
第二个事务读取了这些“脏”数据，并据此作进一步的 处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。

一句话： 事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果 B 事务回滚，A读取的数据无效，不符合一致性要求。
# 不可重读（Non-Repeatable Reads）
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。
一句话：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性
# 幻读（Phantom Reads）
一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
一句话：事务A读取到了事务B提交的新增数据，不符合隔离性。

事物隔离级别能解决的并发的问题：

| 隔离级别 | 脏读  | 不可重复读 | 幻读  |
|------|-----|-------|-----|
| 读未提交 | 可能  | 可能    | 可能  | 
| 读已提交 | 不可能 | 可能    | 可能  | 
| 可重复读 | 不可能 | 不可能   | 可能  | 
| 可串行化 | 不可能 | 不可能   | 不可能 | 

数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。
同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读"和“幻读”并不 敏感,可能更关心数据并发访问的能力。

常看当前数据库的事务隔离级别: `show variables like 'tx_isolation'`;

设置事务隔离级别：`set tx_isolation='REPEATABLE-READ'`;

Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔
离级别，如果Spring设置了就用已经设置的隔离级别。

# 锁概念
锁是计算机协调多个进程或者线程并发访问某一资源的机制。在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资
源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。
# 锁分类
1. 从性能上分为乐观锁(用版本对比来实现)和悲观锁
2. 从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)
3. 读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响
4. 写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁
5. 从对数据操作的粒度分，分为表锁和行锁

## 表锁
每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
一般用在整表数据迁移的场景。

lock table 表名称 read(write),表名称2 read(write);

查看表上加过的锁

show open tables;

删除表锁

unlock tables

## 行锁
每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最
高。
InnoDB与MYISAM的最大不同有两点： InnoDB支持事务（TRANSACTION）， InnoDB支持行级锁

一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞
## 总结
MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自
动给涉及的表加写锁。

InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行
锁。

简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。
# 行锁与事务隔离级别案例分析
## 读未提交：
新建立连接 A，设置当前事务模式为 read uncommitted(未提交读): `set tx_isolation='read-uncommitted';`，查询 actor_explain 的初始值；
再建立连接 B，设置当前事务模式为 read uncommitted(未提交读): `set tx_isolation='read-uncommitted';`，查询 actor_explain 的初始值；
```sql
# A 开启事务, 查看初始数据
begin;
select * from  actor_explain;
+----+----------------------+---------------------+
| id | name                 | update_time         |
+----+----------------------+---------------------+
|  1 | 弗里曼               | 1994-10-14 00:00:00 |
|  2 | 泰隆·鲍华            | 1957-12-17 00:00:00 |
|  3 | 玛莎                 | 2016-03-15 00:00:00 |
|  4 | 安·德鲁扬            | 2014-03-09 00:00:00 |
|  5 | 沃爾克·布魯赫        | 2014-03-09 00:00:00 |
+----+----------------------+---------------------+
# B 开启事务，查看初始数据
begin;
select * from actor_explain;
+----+----------------------+---------------------+
| id | name                 | update_time         |
+----+----------------------+---------------------+
|  1 | 弗里曼               | 1994-10-14 00:00:00 |
|  2 | 泰隆·鲍华            | 1957-12-17 00:00:00 |
|  3 | 玛莎                 | 2016-03-15 00:00:00 |
|  4 | 安·德鲁扬            | 2014-03-09 00:00:00 |
|  5 | 沃爾克·布魯赫        | 2014-03-09 00:00:00 |
+----+----------------------+---------------------+

# 脏读测试
# 在 B 中更新数据，不提交事务
update actor_explain set name='弗里曼123' where id=1;
# 在 A 中查看数据：
select * from actor_explain where id = 1;
+----+--------------+---------------------+
| id | name         | update_time         |
+----+--------------+---------------------+
|  1 | 弗里曼123    | 1994-10-14 00:00:00 |
+----+--------------+---------------------+
可以看到虽然 B 没有提交事物，但是在 A 中却可以看到 B 更新数据后的结果
# 不可重复读
# 在 B 中执行回滚操作：
rollback;
# 然后在 A 中再次查询同样的数据：
select * from actor_explain where id = 1;
+----+-----------+---------------------+
| id | name      | update_time         |
+----+-----------+---------------------+
|  1 | 弗里曼    | 1994-10-14 00:00:00 |
+----+-----------+---------------------+
会发现再次进行操作，数据又不一样了。

# 幻读
# 在 B 中插入一条数据，不提交事务
insert into `actor_explain`(`name`, `update_time`) values ('弗里曼test幻读', '1994-10-14');
# 在 A 中查找数据，会发现多出了一条数据，就像出现了幻觉
mysql> select * from actor_explain where id = 6;
+----+---------------------+---------------------+
| id | name                | update_time         |
+----+---------------------+---------------------+
|  6 | 弗里曼test幻读      | 1994-10-14 00:00:00 |
+----+---------------------+---------------------+
```
## 读已提交
基于上面的操作，设置事务模式为读已提交 `set tx_isolation='read-committed';`，在这种模式下，脏读的情况可以避免。其他两种仍然会出现。
```sql
# 脏读的情况
# 在 B 事务中修改数据，不提交事务：
update actor_explain set name='弗里曼test脏读' where id=1;
# 在 A 事务中查询 id 为 1 的数据
select * from actor_explain where id=1;
+----+-----------+---------------------+
| id | name      | update_time         |
+----+-----------+---------------------+
|  1 | 弗里曼    | 1994-10-14 00:00:00 |
+----+-----------+---------------------+
# 可以看到数据并没有发生改变，当我们在 B 事务提交此次变更，再次查询数据：
# 在 B 事务中提交事务
commit;
# 在 A 事务中查询数据：
select * from actor_explain where id=1;
+----+---------------------+---------------------+
| id | name                | update_time         |
+----+---------------------+---------------------+
|  1 | 弗里曼test脏读      | 1994-10-14 00:00:00 |
+----+---------------------+---------------------+
1 row in set (0.00 sec)
# 可以看到在 A 中，可以看到此时提交后的事务的数据

# 不可重复读
# 因为在 B 事务中提交后，对 A 事务可见，那么就会导致在 A 事务中两次读取的数据不一致。

# 幻读
# 同样在 B 事务中插入数据，A 仍然可见，此时 B 事务对数据库的增删改差会导致 A 事务发生幻觉一样。
```
## 可重复读
同样基于上面的操作将模式设置为可重复读：`set tx_isolation='repeatable-read';`，在这种模式下解决了脏读、不可重复读的情况。
```sql
# 不可重复读，按照读已提交的模式操作，然后要提交此次操作
update actor_explain set name='弗里曼test' where id=1;
commit;
# 在 A 事务中查询同样的数据：
select * from actor_explain where id=1;
+----+-----------+---------------------+
| id | name      | update_time         |
+----+-----------+---------------------+
|  1 | 弗里曼    | 1994-10-14 00:00:00 |
+----+-----------+---------------------+
# 可以看到即使 B 事务提交了数据，但是查询的数据仍然是之前的。但是这种模式仍然没有解决幻读的情况。
# 幻读：当我们向数据库中插入一条数据
# 在 B 事务中插入一条数据，不提交：
insert into `actor_explain`(`id`, `name`, `update_time`) values ('10', '弗里曼test幻读', '1994-10-14');
# 在 A 事务中再次插入相同的数据，会发现主键 id 冲突，出现幻觉，存在了主键 id=10 数据。
ERROR 1062 (23000): Duplicate entry '10' for key 'PRIMARY';
```
## 可串行化
基于上述操作设置可串行化模式 `set tx_isolation='serializable';`, 在这种模式下，任何操作都会加锁。
```sql
基于可重复读模式下的操作插入数据，然后查询，会发现 A 事务被阻塞了。当我们提交后，A 事务查询才能继续进行。
```

## 间隙锁
间隙锁，锁的就是两个值之间的空隙。Mysql默认级别是repeatable-read，有办法解决幻读问题吗?间隙锁 在某些情况下可以解决幻读问题。
```sql
select * from actor_explain;
+----+----------------------+---------------------+
| id | name                 | update_time         |
+----+----------------------+---------------------+
|  1 | 弗里曼               | 1994-10-14 00:00:00 |
|  2 | 泰隆·鲍华            | 1957-12-17 00:00:00 |
|  3 | 玛莎                 | 2016-03-15 00:00:00 |
|  4 | 安·德鲁扬            | 2014-03-09 00:00:00 |
|  5 | 沃爾克·布魯赫        | 2014-03-09 00:00:00 |
| 11 | 弗里曼test幻读       | 1994-10-14 00:00:00 |
+----+----------------------+---------------------+
间隙 id 有：(5,11), (11, +∞), 当在 A 事务中执行 update actor_explain set name = 'zhuge' where id > 8 and id <11; 那么其他事务
没法在这个范围所包含的所有行记录以及行记录所在的间隙里插入或修改任何数据。即 id 在(5,11]区间都无法修改数据。注意最后 11 也是包含在内的。
注意：间隙锁是在可重复读隔离级别下才会生效的
```
## 临键锁
Next-key Locks 是行锁与间隙锁的组合。 像上面 (5,11] 的整个区间可以叫做临键锁。

## 无索引行锁会升级为表锁 
锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁
session1 执行:update actor_explain set name = 800 where id = 1;
session2 对该表任一行操作都会阻塞住 InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为
表锁。

锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)，例如:select * from test_innodb_lock where a = 2 for update; 
这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交

## 行锁分析
通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况
```sql
show status like'innodb_row_lock%';
输出结果：
+-------------------------------+--------+
| Variable_name                 | Value  |
+-------------------------------+--------+
| Innodb_row_lock_current_waits | 0      |
| Innodb_row_lock_time          | 108986 |
| Innodb_row_lock_time_avg      | 18164  |
| Innodb_row_lock_time_max      | 51419  |
| Innodb_row_lock_waits         | 6      |
+-------------------------------+--------+

对各个状态量的说明如下:
Innodb_row_lock_current_waits: 当前正在等待锁定的数量 
Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 
Innodb_row_lock_time_avg: 每次等待所花平均时间 
Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花时间
Innodb_row_lock_waits:系统启动后到现在总共等待的次数
```
比较重要的状态是：
1. Innodb_row_lock_time_avg (等待平均时长) 
2. Innodb_row_lock_waits (等待总次数) 
3. Innodb_row_lock_time(等待总时长)

尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待， 然后根据分析结果着手制定优化计划。

# 查看INFORMATION_SCHEMA系统库锁相关数据表
```sql
-- 查看事务
# 查看事务
select * from INFORMATION_SCHEMA.INNODB_TRX;

# 查看锁
select * from INFORMATION_SCHEMA.INNODB_LOCKS;

# 查看等待锁
select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;

# 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到
kill trx_mysql_thread_id

# 查看锁等待详细信息
show engine innodb status
```

# 死锁测试
```sql
# 设置当前事务隔离级别为可重复读
set tx_isolation='repeatable-read';
# 在 A 终端中执行：
select * from actor_explain where id=1 for update;
# 在 B 终端中执行：
select * from actor_explain where id=2 for update;
# 在 A 终端中执行：
select * from actor_explain where id=2 for update;
# 在终端 A 执行完这条 sql 之后，此时终端 A 会阻塞，等待终端 B 执行完成
# 在 B 终端中执行：
select * from actor_explain where id=1 for update;
# 在终端 B 执行完这条 sql 后，mysql 会提示出现死锁：
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

# 锁优化建议
1. 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁;
2. 合理设计索引，尽量缩小锁的范围;
3. 尽可能减少检索条件范围，避免间隙锁 
4. 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 
5. 尽可能低级别事务隔离






