# MySQL 索引优化实战
向 employees_explain 表中批量插入数据
```sql
-- 批量插入数据
drop procedure if exists insert_emp;
delimiter;
create procedure insert_emp()
begin
	declare i int; 
	set i=1;
	while(i<=10000)do
		insert into employees_explain(`name`, age, position) values(concat('AZH',i), i,'dev');
		set i=i+1;
	end while;
end;
delimiter;
call insert_emp();
```
# 实战测试
范围查找-索引测试：
```sql
explain select * from employees_explain where `name`='AZH1' and age=1 and position>'dev';
explain select * from employees_explain where `name`='AZH1' and age=1 and position='dev';
输出结果：
1	SIMPLE	employees_explain		range	idx_name_age_position	idx_name_age_position	140		1	100.00	Using index condition
1	SIMPLE	employees_explain		ref	idx_name_age_position	idx_name_age_position	140	const,const,const	1	100.00	
可以看到索引生效了。当我们将 name 作为范围条件查找时
explain select * from employees_explain where `name`>'AZH1' and age=1 and position='dev';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+-------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 10123 |     0.50 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+-------+----------+-------------+可以看到并没有走索引。只是可能使用索引
```