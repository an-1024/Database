# MySQL 索引优化实战
向 employees_explain 表中批量插入数据
```sql
-- 批量插入数据
drop procedure if exists insert_emp;
delimiter;
create procedure insert_emp()
begin
	declare i int; 
	set i=1;
	while(i<=10000)do
		insert into employees_explain(`name`, age, position) values(concat('AZH',i), i,'dev');
		set i=i+1;
	end while;
end;
delimiter;
call insert_emp();
```
# 实战测试
范围查找-索引测试：
```sql
explain select * from employees_explain where `name`='AZH1' and age=1 and position>'dev';
explain select * from employees_explain where `name`='AZH1' and age=1 and position='dev';
输出结果：
1	SIMPLE	employees_explain		range	idx_name_age_position	idx_name_age_position	140		1	100.00	Using index condition
1	SIMPLE	employees_explain		ref	idx_name_age_position	idx_name_age_position	140	const,const,const	1	100.00	
可以看到索引生效了。当我们将 name 作为范围条件查找时
explain select * from employees_explain where `name`>'AZH1' and age=1 and position='dev';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
按照最左匹配原则的理解，索引应该是可以生效的，但是经过 MySQL 自己的内部优化，他认为不走索引效率更高, 全表扫描反而更快。测试一下，强制使用索引：
explain select * from employees_explain force index (idx_name_age_position) where `name`>'AZH1000' and age=1000 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL | 50042 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
结果表明强制使用索引生效了。扫描的行数也少了。但是实际的执行结果竟然是全表扫描快。下面的 sql 存在回表，当我们使用覆盖索引的时候，结果是比
全表扫描的结果快的。
```

in 和 or 查询-索引测试
```sql
-- 这张表中有 10w 的数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    3 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
-- 这张表只有 4 条数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    75.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
可以看到数据量的不同，也会影响索引的使用。
-- or 也很类似
explain select * from employees2_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    50.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+

explain select * from employees_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    2 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
```

## 索引下推
前面我们分析过这几条sql的索引：
```sql
explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';
explain select * from employees_explain where `name`>'AZH1' and age=2 and position='dev';
explain select * from employees2_explain where `name` like 'AZH1%' and age=2 and position='dev';
为什么 like 使用了索引，而 > 却走了索引。这就涉及到了索引下推。
```
索引下推是 5.6 版本以后进行的索引优化。

在 5.6 之前，`explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';` 是怎么执行的呢，
先通过 `like` name 找到对应的结果集，不一定有序。然后通过主键回表根据条件查询数据。在 5.6 之后，在 `like` 筛选之后，还会通过 age，position
索引进行比较过滤，然后筛选出一个更小的集合再回表根据 age、position 进行条筛选。

索引下推会减少回表次数，对于 Innodb 引擎的表的索引下推只能用于二级索引。Innodb的主键索引(聚簇索引)树叶子节点上保存的是全行数据，所以这个时候索引下推
并不会起到减少查询全行数据的效果。

## MySQL 是如何计算的
```sql
explain select * from employees_explain where `name` > 'a';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+

explain select * from employees_explain where `name` > 'zzz';

+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+

可以看到只是查询条件中的值不同，使用索引的情况就出现了差别。第一条 sql 没有使用索引。第二条 sql 使用了索引。
```
针对于 name>'a'和name>'zzz'，mysql 最终是否选择走索引或者一张表涉及多个索引，可以使用 `trace` 工具来查看。这个需要我们手动打开
```sql
-- 打开 trace 一般不轻易打开，会影响性能。用完关闭
set session optimizer_trace='enabled=on',end_markers_in_json=on;
-- 执行 sql 语句
select * from employees_explain where `name` > 'a' order by position;
select * from information_schema.OPTIMIZER_TRACE;

-- 整个 sql 执行的大致过程如下：
{
  "steps": [
    {
      "join_preparation": {  -- 第一阶段：SQL 准备阶段， 格式化 sql
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `employees_explain`.`id` AS `id`,`employees_explain`.`name` AS `name`,`employees_explain`.`age` AS `age`,`employees_explain`.`position` AS `position`,`employees_explain`.`hire_time` AS `hire_time` from `employees_explain` where (`employees_explain`.`name` > 'a') order by `employees_explain`.`position`"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": { -- 第二阶段：SQL 优化阶段
        "select#": 1,
        "steps": [
          {
            "condition_processing": { -- 条件处理
              "condition": "WHERE",
              "original_condition": "(`employees_explain`.`name` > 'a')",
            // 。。。。省略
 
          {
            "rows_estimation": [ -- 预估表的访问成本
              {
                "table": "`employees_explain`",
                "range_analysis": {
                  "table_scan": { -- 全表扫描情况
                    "rows": 100085, -- 扫描行数
                    "cost": 20308  -- 查询成本
                  } /* table_scan */,
                  "potential_range_indexes": [ -- 查询可能使用的索引
                    {
                      "index": "PRIMARY",  -- 主键索引
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "idx_name_age_position", -- 辅助索引
                // 。。。省略
                  "analyzing_range_alternatives": { -- 分析各个索引使用成本
                    "range_scan_alternatives": [
                      {
                        "index": "idx_name_age_position",
                        "ranges": [
                          "a < name"  -- 索引使用范围
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": false, -- 使用该索引获取的记录是否按照主键排序
                        "using_mrr": false,
                        "index_only": false,  -- 是否使用覆盖索引
                        "rows": 50042,  -- 索引扫描行数
                        "cost": 60051,  -- 索引使用成本
                        "chosen": false, -- 是否选择该索引,false 不选择
                        "cause": "cost"
                      }
                    ] /* range_scan_alternatives */,
                    // 。。。代码省略
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`employees_explain`",
                "best_access_path": {   -- 最优访问路径
                  "considered_access_paths": [ -- 最终选择的访问路径
                    {
                      "rows_to_scan": 100085,
                      "access_type": "scan",  -- 访问类型：为 scan，全表扫描
                      "resulting_rows": 100085,
                      "cost": 20306,
                      "chosen": true,  -- 确定选择
                      "use_tmp_table": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 100085,
                "cost_for_plan": 20306,
                "sort_cost": 100085,
                "new_cost_for_plan": 120391,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
    // 。。。 代码省略
}
```
# 常见 sql 深入优化
## Order by 与 Group by 优化
```sql
explain select * from employees_explain where `name` = 'DiRenJie' and position = 'dev' order by age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |    10.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
根据结果可以很明显底看出使用了 `name` 索引这一列。而 age 索引列则用在了排序过程中，Extra 中 `Using index condition` 表明用到了索引 age。
再来看一下这一句：
explain select * from employees_explain where `name` > 'DiRenJie' and position = 'dev' order by age;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |    10.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
可以看到 order by 并没有使用到 age 这一列索引。为什么呢？分析一下：
根据最左匹配原则，`name` = 'DiRenJie' 相等之后， age 在索引树中必然是有序的。相比于 `name` > 'DiRenJie'， age 不一定有序，因此也就无法使用
索引。
再来看一下这一句 sql 
explain select * from employees_explain where `name` > 'DiRenJie' order by `position`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
跳过 age 索引列，违背了最左匹配原则，所以 order by 没有使用到索引，出现了 Using filesort。
将 age、position 用于排序，无 Using filesort
explain select * from employees_explain where `name` = 'DiRenJie' order by age, `position`;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
可以看到 order by age, `position` 用到了索引。根据名称之后，age，`position` 排序。当将 age，`position` 顺序改变的时候，就会发现 Extra 中多出了 Using filesort，
-- 违反最左匹配原则的 order by
explain select * from employees_explain where `name` = 'DiRenJie' order by `position`, age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
在联合索引中，是按照 `name`、`age`、`position` 进行排序的。order by 按照 position、age 进行排序，根据索引是无法完成的，因此需要额外进行排序操作。再用一个案例来对我们说得这个有序性进行验证：
-- 最左匹配原则验证
explain select * from employees_explain where `name` = 'DiRenJie' and age = 18 order by `position`, age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref         | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 78      | const,const |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
可以看到根据前面的 `name`、`age` 再加上后面 order by 是根据 position 符合索引的排序条件，不需要再进行额外排序。 
另一种是查询条件中的顺序与索引不一致，也会导致 Extra 出现 Using filesort。
-- 查询顺序与索引不一致
explain select * from employees_explain where `name` = 'DiRenJie' order by age asc, `position` desc;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
根据结果可以看到 order by 按照索引顺序进行查询，还是产生了 Using filesort 这是因为 order by 默认生序， position desc 变成降序，导致
与索引的排方式不同，从而造成了这样的结果。MySQL 8 支持这样的查询条件。
再来看一下下面这条sql
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang') order by age, `position`;
虽然符合了联合索引的顺序，但是根据 `name` 取出的结果集， age `position` 并不是有序的，自然就会出现了 Using filesort。
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    2 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
-- 在数据量比较大的时候，即使使用了索引仍然不会使用到索引
explain select * from employees_explain where `name` > 'A' order by `name`;
这个表中有 10 w 条数据，以 A 开头的有 9w 多条，可能 MySQL 认为全表比索引成本低，所以使用了 Using filesort 进行排序。
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
当使用一个筛选数据结果集比较少的，还是会使用到索引排序的
-- 当筛选的数据量比较小的时候
explain select * from employees_explain where `name` > 'L' order by `name`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
正对这种数据量大的结果集，我们可以通过覆盖索引进行优化
-- 覆盖索引优化这种筛选出的大的数据量
explain select `name` from employees_explain where `name` > 'A' order by `name`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL | 50042 |   100.00 | Using where; Using index |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
```
## Using filesort 文件排序原理详解
### filesort 文件排序方式
1. 单路排序：是一次性取出满足条件的所有字段，然后在 sort buffer 中进行排序；用 trace 工具中可以看到 sort_mode 信息里显示 `< sort_key`,
`additional_fields >` 或者 `< sort_key`, `packed_additional_fields >`；
2. 双路排序：(又叫回表排序模式)：首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完成后
需要再次取回其他需要的字段；用 trace 工具可以看到 sort_mode 信息里显示 `< sort_key, rowid`

MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节)的大小和需要查询的字段总大小来判断使用那种排序模式。
1. 如果字段的总长度小于 max_length_for_sort_data, 那么使用单路排序模式；
2. 如果字段的总长度大于 max_length_for_sort_data，那么使用双路排序模式；

可以自行测试一下：
```sql
默认 max_length_for_sort_data 为 1024 个字节
{
     /* filesort_priority_queue_optimization */,
    "filesort_summary": {  -- 文件排序信息
      "rows": 100000,  -- 预计扫描行数
      "examined_rows": 100000, -- 参与排序的行
      "number_of_tmp_files": 29, -- 使用临时文件的个数，这个值如果为 0 代表全部使用的 sort_buffer 内存排序，否则使用磁盘文件排序。
      "sort_buffer_size": 262056,
      "sort_mode": "<sort_key, packed_additional_fields>" -- 排序方式，小于 sort_key, 表示使用的是单路排序模式
    } /* filesort_summary */
}
```

