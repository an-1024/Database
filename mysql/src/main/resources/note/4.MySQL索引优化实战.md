# MySQL 索引优化实战
向 employees_explain 表中批量插入数据
```sql
-- 批量插入数据
drop procedure if exists insert_emp;
delimiter;
create procedure insert_emp()
begin
	declare i int; 
	set i=1;
	while(i<=10000)do
		insert into employees_explain(`name`, age, position) values(concat('AZH',i), i,'dev');
		set i=i+1;
	end while;
end;
delimiter;
call insert_emp();
```
# 实战测试
范围查找-索引测试：
```sql
explain select * from employees_explain where `name`='AZH1' and age=1 and position>'dev';
explain select * from employees_explain where `name`='AZH1' and age=1 and position='dev';
输出结果：
1	SIMPLE	employees_explain		range	idx_name_age_position	idx_name_age_position	140		1	100.00	Using index condition
1	SIMPLE	employees_explain		ref	idx_name_age_position	idx_name_age_position	140	const,const,const	1	100.00	
可以看到索引生效了。当我们将 name 作为范围条件查找时
explain select * from employees_explain where `name`>'AZH1' and age=1 and position='dev';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
按照最左匹配原则的理解，索引应该是可以生效的，但是经过 MySQL 自己的内部优化，他认为不走索引效率更高, 全表扫描反而更快。测试一下，强制使用索引：
explain select * from employees_explain force index (idx_name_age_position) where `name`>'AZH1000' and age=1000 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL | 50042 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
结果表明强制使用索引生效了。扫描的行数也少了。但是实际的执行结果竟然是全表扫描快。下面的 sql 存在回表，当我们使用覆盖索引的时候，结果是比
全表扫描的结果快的。
```

in 和 or 查询-索引测试
```sql
-- 这张表中有 10w 的数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    3 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
-- 这张表只有 4 条数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    75.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
可以看到数据量的不同，也会影响索引的使用。
-- or 也很类似
explain select * from employees2_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    50.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+

explain select * from employees_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    2 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
```

## 索引下推
前面我们分析过这几条sql的索引：
```sql
explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    1 |     5.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
explain select * from employees_explain where `name`>'AZH1' and age=2 and position='dev';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |     0.50 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
explain select * from employees2_explain where `name` like 'AZH1%' and age=2 and position='dev';
+----+-------------+--------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table              | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees2_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    1 |    25.00 | Using index condition |
+----+-------------+--------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
为什么 like 使用了索引(有时候 like 也不一定会走索引)，而 > 却没有使用索引。这就涉及到了索引下推。
```
索引下推是 5.6 版本以后进行的索引优化。

在 5.6 之前，`explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';` 是怎么执行的呢，
先通过 `like` name 找到对应的结果集，不一定有序。然后通过主键回表根据条件查询数据。在 5.6 之后，在 `like` 筛选之后，还会通过 age，position
索引进行比较过滤，然后筛选出一个更小的集合再回表根据 age、position 进行条筛选。

索引下推会减少回表次数，对于 Innodb 引擎的表的索引下推只能用于二级索引。Innodb的主键索引(聚簇索引)树叶子节点上保存的是全行数据，所以这个时候索引下推
并不会起到减少查询全行数据的效果。

## MySQL 是如何计算的
```sql
explain select * from employees_explain where `name` > 'a';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+

explain select * from employees_explain where `name` > 'zzz';

+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+

可以看到只是查询条件中的值不同，使用索引的情况就出现了差别。第一条 sql 没有使用索引。第二条 sql 使用了索引。
```
针对于 name>'a'和name>'zzz'，mysql 最终是否选择走索引或者一张表涉及多个索引，可以使用 `trace` 工具来查看。这个需要我们手动打开
```sql
-- 打开 trace 一般不轻易打开，会影响性能。用完关闭
set session optimizer_trace='enabled=on',end_markers_in_json=on;
-- 执行 sql 语句
select * from employees_explain where `name` > 'a' order by position;
select * from information_schema.OPTIMIZER_TRACE;

-- 整个 sql 执行的大致过程如下：
{
  "steps": [
    {
      "join_preparation": {  -- 第一阶段：SQL 准备阶段， 格式化 sql
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `employees_explain`.`id` AS `id`,`employees_explain`.`name` AS `name`,`employees_explain`.`age` AS `age`,`employees_explain`.`position` AS `position`,`employees_explain`.`hire_time` AS `hire_time` from `employees_explain` where (`employees_explain`.`name` > 'a') order by `employees_explain`.`position`"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": { -- 第二阶段：SQL 优化阶段
        "select#": 1,
        "steps": [
          {
            "condition_processing": { -- 条件处理
              "condition": "WHERE",
              "original_condition": "(`employees_explain`.`name` > 'a')",
            // 。。。。省略
 
          {
            "rows_estimation": [ -- 预估表的访问成本
              {
                "table": "`employees_explain`",
                "range_analysis": {
                  "table_scan": { -- 全表扫描情况
                    "rows": 100085, -- 扫描行数
                    "cost": 20308  -- 查询成本
                  } /* table_scan */,
                  "potential_range_indexes": [ -- 查询可能使用的索引
                    {
                      "index": "PRIMARY",  -- 主键索引
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "idx_name_age_position", -- 辅助索引
                // 。。。省略
                  "analyzing_range_alternatives": { -- 分析各个索引使用成本
                    "range_scan_alternatives": [
                      {
                        "index": "idx_name_age_position",
                        "ranges": [
                          "a < name"  -- 索引使用范围
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": false, -- 使用该索引获取的记录是否按照主键排序
                        "using_mrr": false,
                        "index_only": false,  -- 是否使用覆盖索引
                        "rows": 50042,  -- 索引扫描行数
                        "cost": 60051,  -- 索引使用成本
                        "chosen": false, -- 是否选择该索引,false 不选择
                        "cause": "cost"
                      }
                    ] /* range_scan_alternatives */,
                    // 。。。代码省略
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`employees_explain`",
                "best_access_path": {   -- 最优访问路径
                  "considered_access_paths": [ -- 最终选择的访问路径
                    {
                      "rows_to_scan": 100085,
                      "access_type": "scan",  -- 访问类型：为 scan，全表扫描
                      "resulting_rows": 100085,
                      "cost": 20306,
                      "chosen": true,  -- 确定选择
                      "use_tmp_table": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 100085,
                "cost_for_plan": 20306,
                "sort_cost": 100085,
                "new_cost_for_plan": 120391,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
    // 。。。 代码省略
}
```
# 常见 sql 深入优化
## Order by 与 Group by 优化
```sql
explain select * from employees_explain where `name` = 'DiRenJie' and position = 'dev' order by age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |    10.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
根据结果可以很明显底看出使用了 `name` 索引这一列。而 age 索引列则用在了排序过程中，Extra 中 `Using index condition` 表明用到了索引 age。
再来看一下这一句：
explain select * from employees_explain where `name` > 'DiRenJie' and position = 'dev' order by age;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |    10.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
可以看到 order by 并没有使用到 age 这一列索引。为什么呢？分析一下：
根据最左匹配原则，`name` = 'DiRenJie' 相等之后， age 在索引树中必然是有序的。相比于 `name` > 'DiRenJie'， age 不一定有序，因此也就无法使用
索引。
再来看一下这一句 sql 
explain select * from employees_explain where `name` > 'DiRenJie' order by `position`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
跳过 age 索引列，违背了最左匹配原则，所以 order by 没有使用到索引，出现了 Using filesort。
将 age、position 用于排序，无 Using filesort
explain select * from employees_explain where `name` = 'DiRenJie' order by age, `position`;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
可以看到 order by age, `position` 用到了索引。根据名称之后，age，`position` 排序。当将 age，`position` 顺序改变的时候，就会发现 Extra 中多出了 Using filesort，
-- 违反最左匹配原则的 order by
explain select * from employees_explain where `name` = 'DiRenJie' order by `position`, age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
在联合索引中，是按照 `name`、`age`、`position` 进行排序的。order by 按照 position、age 进行排序，根据索引是无法完成的，因此需要额外进行排序操作。再用一个案例来对我们说得这个有序性进行验证：
-- 最左匹配原则验证
explain select * from employees_explain where `name` = 'DiRenJie' and age = 18 order by `position`, age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref         | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 78      | const,const |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
可以看到根据前面的 `name`、`age` 再加上后面 order by 是根据 position 符合索引的排序条件，不需要再进行额外排序。 
另一种是查询条件中的顺序与索引不一致，也会导致 Extra 出现 Using filesort。
-- 查询顺序与索引不一致
explain select * from employees_explain where `name` = 'DiRenJie' order by age asc, `position` desc;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
根据结果可以看到 order by 按照索引顺序进行查询，还是产生了 Using filesort 这是因为 order by 默认生序， position desc 变成降序，导致
与索引的排方式不同，从而造成了这样的结果。MySQL 8 支持这样的查询条件。
再来看一下下面这条sql
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang') order by age, `position`;
虽然符合了联合索引的顺序，但是根据 `name` 取出的结果集， age `position` 并不是有序的，自然就会出现了 Using filesort。
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    2 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
-- 在数据量比较大的时候，即使使用了索引仍然不会使用到索引
explain select * from employees_explain where `name` > 'A' order by `name`;
这个表中有 10 w 条数据，以 A 开头的有 9w 多条，可能 MySQL 认为全表比索引成本低，所以使用了 Using filesort 进行排序。
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
当使用一个筛选数据结果集比较少的，还是会使用到索引排序的
-- 当筛选的数据量比较小的时候
explain select * from employees_explain where `name` > 'L' order by `name`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
正对这种数据量大的结果集，我们可以通过覆盖索引进行优化
-- 覆盖索引优化这种筛选出的大的数据量
explain select `name` from employees_explain where `name` > 'A' order by `name`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL | 50042 |   100.00 | Using where; Using index |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
```
## Using filesort 文件排序原理详解
### filesort 文件排序方式
1. 单路排序：是一次性取出满足条件的所有字段，然后在 sort buffer 中进行排序；用 trace 工具中可以看到 sort_mode 信息里显示 `< sort_key`,
`additional_fields >` 或者 `< sort_key`, `packed_additional_fields >`；
2. 双路排序：(又叫回表排序模式)：首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完成后
需要再次取回其他需要的字段；用 trace 工具可以看到 sort_mode 信息里显示 `< sort_key, rowid`

MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节)的大小和需要查询的字段总大小来判断使用那种排序模式。
1. 如果字段的总长度小于 max_length_for_sort_data, 那么使用单路排序模式；
2. 如果字段的总长度大于 max_length_for_sort_data，那么使用双路排序模式；

可以自行测试一下：
```sql
默认 max_length_for_sort_data 为 1024 个字节
{
     /* filesort_priority_queue_optimization */,
    "filesort_summary": {  -- 文件排序信息
      "rows": 100000,  -- 预计扫描行数
      "examined_rows": 100000, -- 参与排序的行
      "number_of_tmp_files": 29, -- 使用临时文件的个数，这个值如果为 0 代表全部使用的 sort_buffer 内存排序，否则使用磁盘文件排序。
      "sort_buffer_size": 262056,
      "sort_mode": "<sort_key, packed_additional_fields>" -- 排序方式，小于 sort_key, 表示使用的是单路排序模式
    } /* filesort_summary */
}

可以手动设置 max_length_for_sort_data 长度，来看一下双路排模式:
set max_length_for_sort_data = 10; -- employees表所有字段长度总和肯定大于10字节
select * from employees_explain where name = 'DiRenJie' order by position;
select * from information_schema.OPTIMIZER_TRACE;
输出的结果：
{
    "filesort_summary": {
      "rows": 1,
      "examined_rows": 1,
      "number_of_tmp_files": 0,
      "sort_buffer_size": 262136,
      "sort_mode": "<sort_key, rowid>" -- 双路排序模式
    } /* filesort_summary */
  }
}

来分析一下执行过程：
我们先看单路排序的详细过程:
1. 从索引name找到第一个满足 name = ‘zhuge’ 条件的主键 id 
2. 根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中 
3. 从索引name找到下一个满足 name = ‘zhuge’ 条件的主键 id 
4. 重复步骤 2、3 直到不满足 name = ‘zhuge’
5. 对 sort_buffer 中的数据按照字段 position 进行排序
6. 返回结果给客户端
我们再看下双路排序的详细过程:
1. 从索引 name 找到第一个满足 name = ‘zhuge’ 的主键id
2. 根据主键 id 取出整行，把排序字段 position 和主键 id 这两个字段放到 sort buffer 中
3. 从索引 name 取下一个满足 name = ‘zhuge’ 记录的主键 id
4. 重复 3、4 直到不满足 name = ‘zhuge’
5. 对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序
6. 遍历排序好的 id 和字段 position，按照 id 的值回到原表中取出 所有字段的值返回给客户端
```
其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键 和需要排序的字段放到 sort buffer 
中进行排序，然后再通过主键回到原表查询需要的字段。 如果 MySQL 排序内存 sort_buffer 配置的比较小并且没有条件继续增加了，可以适当把 
max_length_for_sort_data 配置小点，让优化器选择使用双路排序算法，可以在sort_buffer 中一次排序更 多的行，只是需要再根据主键回到原表取数据。
如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器 优先选择全字段排序(单路排序)，把需要的
字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。
所以，MySQL通过 max_length_for_sort_data 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。
**注意**：如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增 大sort_buffer(默认1M)，mysql很多参数设
置都是做过优化的，不要轻易调整。

# 索引设计原则
1. 代码先行，索引后上：一般应该等到主体业务功能开发完毕，把涉及到该表相关sql都要拿出来分析之后再建立索引
2. 联合索引尽量覆盖条：比如可以设计一个或者两三个联合索引(尽量少建单值索引)，让每一个联合索引都尽量去包含sql语句里的 where、order by、
group by的字段，还要确保这些联合索引的字段顺序尽量满足sql查询的最左前缀原则；
3. 不要在小基数字段上建立索：一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能发挥出B+树快速二分查找的优势来。这里值
比较多的意思是可以理解为有多种类型。比如像性别，除了男、就女这两种值，那么该字段的基数就是2，给这种字段添加索引，没有办法进行二分查找，没有添加索引
的必要。
4. 长字符串我们可以采用前缀索引：尽量选择字段类型较小的列设计索引。因为这样占用磁盘空间较小，搜索性能会有所提高。实在买办法，看看是否可以
针对这个字段的前缀建立索引(一般取字段的前20个字符就差不多了)。但是使用前缀索引需要注意：当我们是使用前缀索引的时候，mySQL 会先根据索引列的前
20 个字符来搜索，然后再回到聚簇索引中提取出完整的字段来比较。而且 order by 条件是没办法使用索引的。 group by 也是一样的道理。
5. where与order by冲突时优先where：在where和order by出现索引设计冲突时，我们一般先满足 where 条件先筛选出一部分指定的数据，然后再进行排序，
这样相对来说排序成本会小很多。

## 设计三星索引
1. 索引将相关的记录放到一起获得一星(缩小查询范围)；
2. 如果索引中数据顺序和查找排列顺序一致则获得二星；
3. 如果索引中的列包含了查询中需要的全部列则获得三星；

## 多列索引设计原则
1. 将实际应用中选择性最高的列放在索引最前列；
2. 需要根据那些运行频率最高的查询来调整列的顺序；
3. 在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求；
## 分页查询优化
```sql
-- 根据自增且连续的主键排序的分页查询
explain select * from employees_explain limit 10000, 10;
mySQL 底层执行地时候不是从 10000 开始的，而是从 1 开始查到 10010，最终舍弃前面的数据，只保留 10 条数据。
-- 优化
explain select * from employees_explain where id > 90000 limit 10;
该 sql 就可以限定查询 id 从 90001 开始查询，筛选出 10 条数据，并且用到了主键索引。
输出结果：
+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
| id | select_type | table             | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 18754 |   100.00 | Using where |
+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
但是这种查询优化的条件比较苛刻，主键id必须自增且连续。当我们删除数据的时候，就会导致查询的结果集不一样了。
-- 根据非主键字段优化
explain select * from employees_explain order by name limit 90000, 5;
输出结果：
+----+-------------+-------------------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table             | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-------------------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 100085 |   100.00 | Using filesort |
+----+-------------+-------------------+------------+------+---------------+------+---------+------+--------+----------+----------------+
没有用到索引，并且还用了文件排序 Using filesort。查询到的结果：
-- 优化
explain select * from employees_explain e inner join (select id from employees_explain order by `name` limit 90000, 5) ed on e.id=ed.id;
输出结果：
+----+-------------+-------------------+------------+--------+---------------+-----------------------+---------+-------+-------+----------+-------------+
| id | select_type | table             | partitions | type   | possible_keys | key                   | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+-------------------+------------+--------+---------------+-----------------------+---------+-------+-------+----------+-------------+
|  1 | PRIMARY     | <derived2>        | NULL       | ALL    | NULL          | NULL                  | NULL    | NULL  | 90005 |   100.00 | NULL        |
|  1 | PRIMARY     | e                 | NULL       | eq_ref | PRIMARY       | PRIMARY               | 4       | ed.id |     1 |   100.00 | NULL        |
|  2 | DERIVED     | employees_explain | NULL       | index  | NULL          | idx_name_age_position | 140     | NULL  | 90005 |   100.00 | Using index |
+----+-------------+-------------------+------------+--------+---------------+-----------------------+---------+-------+-------+----------+-------------+
可以看到首先执行根据主键 id 进行过滤的数据，用到了索引，且解决了文件排序。接着用主键外层 sql 的主键 id 进行关联。此时的临时表 derived2 只有 5 条数据，即使全表扫描也不会带来什么影响。
```
## Join 关联表查询优化
```sql
# 示例表
-- 创建测试关联表
CREATE TABLE `join_test_t1` (
                                `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) DEFAULT NULL,
                                `b` int(11) DEFAULT NULL,
                                PRIMARY KEY (`id`),
                                KEY `idx_a` (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
-- 创建关联测试表 2
create table join_test_t2 like join_test_t1;

-- 向 join_test_t1 表中插入 1 万条数据
drop procedure if exists insert_t1;
delimiter;
create procedure insert_t1()
begin
declare i int; set i=1; while(i<=10000)do
     insert into join_test_t1(a,b) values(i,i);
set i=i+1; end while;
end;
delimiter;
call insert_t1();

-- 往join_test_t2表插入100行记录
drop procedure if exists insert_t2;
delimiter;
create procedure insert_t2()
begin
declare i int; set i=1; while(i<=100)do
    insert into join_test_t1(a,b) values(i,i);
set i=i+1; end while;
end;
delimiter;
call insert_t2();
```

### 嵌套循环连接算法 Nested-Loop Join(NLJ)算法
一次一行循环地从第一张表(称为驱动表)中读取行，在这行数据中取到关联字段，根据关联字段在另一张表(被驱动 表)里取出满足条件的行，
然后取出两张表的结果合集
```sql
-- 联合查询
explain select * from join_test_t1  t1 inner join join_test_t2 t2 on t1.a = t2.a;
输出结果：
+----+-------------+-------+------------+------+---------------+-------+---------+------------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref                    | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+-------+---------+------------------------+------+----------+-------------+
|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL                   |    1 |   100.00 | Using where |
|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | dev_server01_data.t2.a |    1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+-------+---------+------------------------+------+----------+-------------+
从执行计划中，驱动表是 t2，被驱动表是 t1。先执行的就是驱动表(执行计划结果的 id 一致，则按照从上到下的顺序执行)；优化器一般会选择小表作为
驱动表。所以在使用 inner join 时，排在前面的表不一定就是驱动表。上述 sql 执行的顺序如下：
1. 从表 t2 中读取一行数据(如果t2表有查询过滤条件的，会从过滤结果里取出一行数据);
2. 从第 1 步的数据中，取出关联字段 a，到表 t1 中查找;
3. 取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端;
4. 重复上面 3 步。

整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 
t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了 200 行。 如果被驱动表的
关联字段没索引，使用NLJ算法性能会比较低(下面有详细解释)，mysql会选择Block Nested-Loop Join 算法。

当使用left join时，左表是驱动表，右表是被驱动表，当使用right join时，右表时驱动表，左表是被驱动表， 当使用join时，mysql会选择数据量比
较小的表作为驱动表，大表作为被驱动表。

使用了 NLJ算法。一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer 则表示使用的 join 算 法是 NLJ。
```
### 基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法
把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比。Extra 中 的Using join 
buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。

```sql
explain select * from join_test_t1  t1 inner join join_test_t2 t2 on t1.b = t2.b;
输出结果：
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                              |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------------------------------------------+
|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                               |
|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10437 |    10.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------------------------------------------+

1. 把 t2 的所有数据放入到 join_buffer 中
2. 把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比 
3. 返回满足 join 条件的数据
整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 
join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。
这个例子里表 t2 才 100 行，要是表 t2 是一个大表，join_buffer 放不下怎么办呢?
join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t2 的所有数据话，策略很简单， 就是分段放。
比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然 后从 t1 
表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空 join_buffer ，再放入 t2 表剩余200行记录，再 次从 t1 表里取数据跟 
join_buffer 中数据对比。所以就多扫了一次 t1 表。
```
被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢?
如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。 很显然，用BNL磁盘扫描次数少很多，
相比于磁盘扫描，BNL的内存计算会快得多。 因此MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 
算法，有 索引的情况下 NLJ 算法比 BNL算法性能更高

所以针对关联 sql 的优化大致分为两个点：
1. 关联字段添加索引：让 mysql 做 join 操作时尽量选择 NLJ 算法；
2. 小表驱动大表，写多表连接 sql 的时，如果明确知道那张表是小表，可以用 straight_join 写法固定连接驱动方式，省去 mysql 优化器自己判断的
时间。

straight_join解释:straight_join功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。
比如:select * from t2 straight_join t1 on t2.a = t1.a; 代表指定mysql选着 t2 表作为驱动表。
straight_join只适用于inner join，并不适用于left join，right join。(因为left join，right join已经代表指 定了表的执行顺序)
尽可能让优化器去判断，因为大部分情况下mysql优化器是比人要聪明的。使用straight_join一定要慎重，因为部分情况下人为指定的执行顺序并不一
定会比优化引擎要靠谱。

#### 对于小表定义的明确
在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，**计算参与 join 的各个字段的总数据量**，数据量小的那个表，就是“小表”，
应该作为驱动表。

#### in和 exsits 优化
原则： 小表(根据筛选条件数据集小的表)驱动大表；
```sql
in:当B表的数据集小于A表的数据集时，in优于exists
explain select * from join_test_t1 t1 where t1.id in (select id from join_test_t2)
等价于下面这个公式：
for(select id from join_test_t2){
    select * from join_test_t1 t1 where t1.id = t2.id 
}
输出结果：
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------------+
| id | select_type | table        | partitions | type   | possible_keys | key     | key_len | ref                               | rows | filtered | Extra       |
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------------+
|  1 | SIMPLE      | join_test_t2 | NULL       | index  | PRIMARY       | idx_a   | 5       | NULL                              |  100 |   100.00 | Using index |
|  1 | SIMPLE      | t1           | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | dev_server01_data.join_test_t2.id |    1 |   100.00 | NULL        |
+----+-------------+--------------+------------+--------+---------------+---------+---------+-----------------------------------+------+----------+-------------+

exists: 当A表的数据集小于B表的数据集时，exists优于in
将主查询A的数据，放到子查询B中做条件验证，根据验证结果(true或false)来决定主查询的数据是否保留
explain select * from join_test_t1 t1 where exists (select 1 from join_test_t2 t2 where t2.id = t1.id)
等价于：
for(select id from join_test_t1){
    select * from join_test_t2 t2 where t2.id = t1.id
}
1. EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会 忽略SELECT清单,因此没有区别
2. EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比 
3. **EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析**
```
## count(*) 优化
分析一下以下 sql 的执行效率：
```sql
EXPLAIN select count(1) from employees_explain;
输出结果：
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type  | possible_keys | key                   | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | index | NULL          | idx_name_age_position | 140     | NULL | 100085 |   100.00 | Using index |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
EXPLAIN select count(id) from employees_explain;
输出结果：
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type  | possible_keys | key                   | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | index | NULL          | idx_name_age_position | 140     | NULL | 100085 |   100.00 | Using index |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
EXPLAIN select count(`name`) from employees_explain;
输出结果
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type  | possible_keys | key                   | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | index | NULL          | idx_name_age_position | 140     | NULL | 100085 |   100.00 | Using index |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
EXPLAIN select count(*) from employees_explain;
输出结果：
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type  | possible_keys | key                   | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | index | NULL          | idx_name_age_position | 140     | NULL | 100085 |   100.00 | Using index |
+----+-------------+-------------------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-------------+

根据分析结果可以看到执行效率都差不多。进一步分析 sql 语句执行的效率：
1. 字段有索引:count(*)≈count(1)>count(字段)>count(主键 id)：字段有索引，count(字段)统计走二级索引，二级索引存储数据比主键索引少(主键索引是聚簇索引)，
所以count(字段)>count(主键 id);
2. 字段无索引:count(*)≈count(1)>count(主键 id)>count(字段): 字段没有索引count(字段)统计走不了索引， count(主键 id)还可以走主键索引，所以count(主键 id)>count(字段);

count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出 字段，所以理论上count(1)比count(字段)会快一点。
count(*) 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，所以不需要用 count(列名)或count(常量)来替代 count(*)。 
为什么对于count(id)，mysql最终选择辅助索引而不是主键聚集索引?因为二级索引相对主键索引存储数据更少，检索性能应该更高，mysql内部做了点优化(应该是在5.7版本才优化)。
```
## MySQL 查询成本计算
主要分为  I/O 成本：1.0；CPU 成本：0.2

单表查询的成本：
1. 根据查询条件查询出所有可能用到的索引；
2. 计算使用不同索引查询花费的时间；
3. 计算全表扫描的时间；
4. 对比上述执行时间，找出最优解；

查看一条 sql 的执行条件：
```sql
explain format=json select * from actor_explain where id = 1;
```




