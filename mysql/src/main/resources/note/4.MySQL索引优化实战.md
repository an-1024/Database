# MySQL 索引优化实战
向 employees_explain 表中批量插入数据
```sql
-- 批量插入数据
drop procedure if exists insert_emp;
delimiter;
create procedure insert_emp()
begin
	declare i int; 
	set i=1;
	while(i<=10000)do
		insert into employees_explain(`name`, age, position) values(concat('AZH',i), i,'dev');
		set i=i+1;
	end while;
end;
delimiter;
call insert_emp();
```
# 实战测试
范围查找-索引测试：
```sql
explain select * from employees_explain where `name`='AZH1' and age=1 and position>'dev';
explain select * from employees_explain where `name`='AZH1' and age=1 and position='dev';
输出结果：
1	SIMPLE	employees_explain		range	idx_name_age_position	idx_name_age_position	140		1	100.00	Using index condition
1	SIMPLE	employees_explain		ref	idx_name_age_position	idx_name_age_position	140	const,const,const	1	100.00	
可以看到索引生效了。当我们将 name 作为范围条件查找时
explain select * from employees_explain where `name`>'AZH1' and age=1 and position='dev';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
按照最左匹配原则的理解，索引应该是可以生效的，但是经过 MySQL 自己的内部优化，他认为不走索引效率更高, 全表扫描反而更快。测试一下，强制使用索引：
explain select * from employees_explain force index (idx_name_age_position) where `name`>'AZH1000' and age=1000 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL | 50042 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
结果表明强制使用索引生效了。扫描的行数也少了。但是实际的执行结果竟然是全表扫描快。下面的 sql 存在回表，当我们使用覆盖索引的时候，结果是比
全表扫描的结果快的。
```

in 和 or 查询-索引测试
```sql
-- 这张表中有 10w 的数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    3 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
-- 这张表只有 4 条数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    75.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
可以看到数据量的不同，也会影响索引的使用。
-- or 也很类似
explain select * from employees2_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    50.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+

explain select * from employees_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    2 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
```

## 索引下推
前面我们分析过这几条sql的索引：
```sql
explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';
explain select * from employees_explain where `name`>'AZH1' and age=2 and position='dev';
explain select * from employees2_explain where `name` like 'AZH1%' and age=2 and position='dev';
为什么 like 使用了索引，而 > 却走了索引。这就涉及到了索引下推。
```
索引下推是 5.6 版本以后进行的索引优化。

在 5.6 之前，`explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';` 是怎么执行的呢，
先通过 `like` name 找到对应的结果集，不一定有序。然后通过主键回表根据条件查询数据。在 5.6 之后，在 `like` 筛选之后，还会通过 age，position
索引进行比较过滤，然后筛选出一个更小的集合再回表根据 age、position 进行条筛选。

索引下推会减少回表次数，对于 Innodb 引擎的表的索引下推只能用于二级索引。Innodb的主键索引(聚簇索引)树叶子节点上保存的是全行数据，所以这个时候索引下推
并不会起到减少查询全行数据的效果。

## MySQL 是如何计算的
```sql
explain select * from employees_explain where `name` > 'a';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+

explain select * from employees_explain where `name` > 'zzz';

+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+

可以看到只是查询条件中的值不同，使用索引的情况就出现了差别。第一条 sql 没有使用索引。第二条 sql 使用了索引。
```
针对于 name>'a'和name>'zzz'，mysql 最终是否选择走索引或者一张表涉及多个索引，可以使用 `trace` 工具来查看。这个需要我们手动打开
```sql
-- 打开 trace 一般不轻易打开，会影响性能。用完关闭
set session optimizer_trace='enabled=on',end_markers_in_json=on;
-- 执行 sql 语句
select * from employees_explain where `name` > 'a' order by position;
select * from information_schema.OPTIMIZER_TRACE;

-- 整个 sql 执行的大致过程如下：
{
  "steps": [
    {
      "join_preparation": {  -- 第一阶段：SQL 准备阶段， 格式化 sql
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `employees_explain`.`id` AS `id`,`employees_explain`.`name` AS `name`,`employees_explain`.`age` AS `age`,`employees_explain`.`position` AS `position`,`employees_explain`.`hire_time` AS `hire_time` from `employees_explain` where (`employees_explain`.`name` > 'a') order by `employees_explain`.`position`"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": { -- 第二阶段：SQL 优化阶段
        "select#": 1,
        "steps": [
          {
            "condition_processing": { -- 条件处理
              "condition": "WHERE",
              "original_condition": "(`employees_explain`.`name` > 'a')",
            // 。。。。省略
 
          {
            "rows_estimation": [ -- 预估表的访问成本
              {
                "table": "`employees_explain`",
                "range_analysis": {
                  "table_scan": { -- 全表扫描情况
                    "rows": 100085, -- 扫描行数
                    "cost": 20308  -- 查询成本
                  } /* table_scan */,
                  "potential_range_indexes": [ -- 查询可能使用的索引
                    {
                      "index": "PRIMARY",  -- 主键索引
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "idx_name_age_position", -- 辅助索引
                // 。。。省略
                  "analyzing_range_alternatives": { -- 分析各个索引使用成本
                    "range_scan_alternatives": [
                      {
                        "index": "idx_name_age_position",
                        "ranges": [
                          "a < name"  -- 索引使用范围
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": false, -- 使用该索引获取的记录是否按照主键排序
                        "using_mrr": false,
                        "index_only": false,  -- 是否使用覆盖索引
                        "rows": 50042,  -- 索引扫描行数
                        "cost": 60051,  -- 索引使用成本
                        "chosen": false, -- 是否选择该索引,false 不选择
                        "cause": "cost"
                      }
                    ] /* range_scan_alternatives */,
                    // 。。。代码省略
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`employees_explain`",
                "best_access_path": {   -- 最优访问路径
                  "considered_access_paths": [ -- 最终选择的访问路径
                    {
                      "rows_to_scan": 100085,
                      "access_type": "scan",  -- 访问类型：为 scan，全表扫描
                      "resulting_rows": 100085,
                      "cost": 20306,
                      "chosen": true,  -- 确定选择
                      "use_tmp_table": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 100085,
                "cost_for_plan": 20306,
                "sort_cost": 100085,
                "new_cost_for_plan": 120391,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
    // 。。。 代码省略
}
```

