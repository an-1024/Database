# MySQL 索引优化实战
向 employees_explain 表中批量插入数据
```sql
-- 批量插入数据
drop procedure if exists insert_emp;
delimiter;
create procedure insert_emp()
begin
	declare i int; 
	set i=1;
	while(i<=10000)do
		insert into employees_explain(`name`, age, position) values(concat('AZH',i), i,'dev');
		set i=i+1;
	end while;
end;
delimiter;
call insert_emp();
```
# 实战测试
范围查找-索引测试：
```sql
explain select * from employees_explain where `name`='AZH1' and age=1 and position>'dev';
explain select * from employees_explain where `name`='AZH1' and age=1 and position='dev';
输出结果：
1	SIMPLE	employees_explain		range	idx_name_age_position	idx_name_age_position	140		1	100.00	Using index condition
1	SIMPLE	employees_explain		ref	idx_name_age_position	idx_name_age_position	140	const,const,const	1	100.00	
可以看到索引生效了。当我们将 name 作为范围条件查找时
explain select * from employees_explain where `name`>'AZH1' and age=1 and position='dev';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
按照最左匹配原则的理解，索引应该是可以生效的，但是经过 MySQL 自己的内部优化，他认为不走索引效率更高, 全表扫描反而更快。测试一下，强制使用索引：
explain select * from employees_explain force index (idx_name_age_position) where `name`>'AZH1000' and age=1000 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL | 50042 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+-----------------------+
结果表明强制使用索引生效了。扫描的行数也少了。但是实际的执行结果竟然是全表扫描快。下面的 sql 存在回表，当我们使用覆盖索引的时候，结果是比
全表扫描的结果快的。
```

in 和 or 查询-索引测试
```sql
-- 这张表中有 10w 的数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    3 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
-- 这张表只有 4 条数据
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang', 'AZH1') and age = 23 and position='dev';
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    75.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
可以看到数据量的不同，也会影响索引的使用。
-- or 也很类似
explain select * from employees2_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys         | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees2_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL |    4 |    50.00 | Using where |
+----+-------------+--------------------+------------+------+-----------------------+------+---------+------+------+----------+-------------+

explain select * from employees_explain where (`name`='DiRenJie' or `name`='LiYuanFang') and age = 23 and position='dev';
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 140     | NULL |    2 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
```

## 索引下推
前面我们分析过这几条sql的索引：
```sql
explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';
explain select * from employees_explain where `name`>'AZH1' and age=2 and position='dev';
explain select * from employees2_explain where `name` like 'AZH1%' and age=2 and position='dev';
为什么 like 使用了索引，而 > 却走了索引。这就涉及到了索引下推。
```
索引下推是 5.6 版本以后进行的索引优化。

在 5.6 之前，`explain select * from employees_explain where `name` like 'Li%' and age=23 and position='dev';` 是怎么执行的呢，
先通过 `like` name 找到对应的结果集，不一定有序。然后通过主键回表根据条件查询数据。在 5.6 之后，在 `like` 筛选之后，还会通过 age，position
索引进行比较过滤，然后筛选出一个更小的集合再回表根据 age、position 进行条筛选。

索引下推会减少回表次数，对于 Innodb 引擎的表的索引下推只能用于二级索引。Innodb的主键索引(聚簇索引)树叶子节点上保存的是全行数据，所以这个时候索引下推
并不会起到减少查询全行数据的效果。

## MySQL 是如何计算的
```sql
explain select * from employees_explain where `name` > 'a';
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-------------+

explain select * from employees_explain where `name` > 'zzz';

+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+

可以看到只是查询条件中的值不同，使用索引的情况就出现了差别。第一条 sql 没有使用索引。第二条 sql 使用了索引。
```
针对于 name>'a'和name>'zzz'，mysql 最终是否选择走索引或者一张表涉及多个索引，可以使用 `trace` 工具来查看。这个需要我们手动打开
```sql
-- 打开 trace 一般不轻易打开，会影响性能。用完关闭
set session optimizer_trace='enabled=on',end_markers_in_json=on;
-- 执行 sql 语句
select * from employees_explain where `name` > 'a' order by position;
select * from information_schema.OPTIMIZER_TRACE;

-- 整个 sql 执行的大致过程如下：
{
  "steps": [
    {
      "join_preparation": {  -- 第一阶段：SQL 准备阶段， 格式化 sql
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `employees_explain`.`id` AS `id`,`employees_explain`.`name` AS `name`,`employees_explain`.`age` AS `age`,`employees_explain`.`position` AS `position`,`employees_explain`.`hire_time` AS `hire_time` from `employees_explain` where (`employees_explain`.`name` > 'a') order by `employees_explain`.`position`"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": { -- 第二阶段：SQL 优化阶段
        "select#": 1,
        "steps": [
          {
            "condition_processing": { -- 条件处理
              "condition": "WHERE",
              "original_condition": "(`employees_explain`.`name` > 'a')",
            // 。。。。省略
 
          {
            "rows_estimation": [ -- 预估表的访问成本
              {
                "table": "`employees_explain`",
                "range_analysis": {
                  "table_scan": { -- 全表扫描情况
                    "rows": 100085, -- 扫描行数
                    "cost": 20308  -- 查询成本
                  } /* table_scan */,
                  "potential_range_indexes": [ -- 查询可能使用的索引
                    {
                      "index": "PRIMARY",  -- 主键索引
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "idx_name_age_position", -- 辅助索引
                // 。。。省略
                  "analyzing_range_alternatives": { -- 分析各个索引使用成本
                    "range_scan_alternatives": [
                      {
                        "index": "idx_name_age_position",
                        "ranges": [
                          "a < name"  -- 索引使用范围
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": false, -- 使用该索引获取的记录是否按照主键排序
                        "using_mrr": false,
                        "index_only": false,  -- 是否使用覆盖索引
                        "rows": 50042,  -- 索引扫描行数
                        "cost": 60051,  -- 索引使用成本
                        "chosen": false, -- 是否选择该索引,false 不选择
                        "cause": "cost"
                      }
                    ] /* range_scan_alternatives */,
                    // 。。。代码省略
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`employees_explain`",
                "best_access_path": {   -- 最优访问路径
                  "considered_access_paths": [ -- 最终选择的访问路径
                    {
                      "rows_to_scan": 100085,
                      "access_type": "scan",  -- 访问类型：为 scan，全表扫描
                      "resulting_rows": 100085,
                      "cost": 20306,
                      "chosen": true,  -- 确定选择
                      "use_tmp_table": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 100085,
                "cost_for_plan": 20306,
                "sort_cost": 100085,
                "new_cost_for_plan": 120391,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
    // 。。。 代码省略
}
```
# 常见 sql 深入优化
## Order by 与 Group by 优化
```sql
explain select * from employees_explain where `name` = 'DiRenJie' and position = 'dev' order by age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |    10.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
根据结果可以很明显底看出使用了 `name` 索引这一列。而 age 索引列则用在了排序过程中，Extra 中 `Using index condition` 表明用到了索引 age。
再来看一下这一句：
explain select * from employees_explain where `name` > 'DiRenJie' and position = 'dev' order by age;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |    10.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
可以看到 order by 并没有使用到 age 这一列索引。为什么呢？分析一下：
根据最左匹配原则，`name` = 'DiRenJie' 相等之后， age 在索引树中必然是有序的。相比于 `name` > 'DiRenJie'， age 不一定有序，因此也就无法使用
索引。
再来看一下这一句 sql 
explain select * from employees_explain where `name` > 'DiRenJie' order by `position`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
跳过 age 索引列，违背了最左匹配原则，所以 order by 没有使用到索引，出现了 Using filesort。
将 age、position 用于排序，无 Using filesort
explain select * from employees_explain where `name` = 'DiRenJie' order by age, `position`;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
可以看到 order by age, `position` 用到了索引。根据名称之后，age，`position` 排序。当将 age，`position` 顺序改变的时候，就会发现 Extra 中多出了 Using filesort，
-- 违反最左匹配原则的 order by
explain select * from employees_explain where `name` = 'DiRenJie' order by `position`, age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
在联合索引中，是按照 `name`、`age`、`position` 进行排序的。order by 按照 position、age 进行排序，根据索引是无法完成的，因此需要额外进行排序操作。再用一个案例来对我们说得这个有序性进行验证：
-- 最左匹配原则验证
explain select * from employees_explain where `name` = 'DiRenJie' and age = 18 order by `position`, age;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref         | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 78      | const,const |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-----------------------+
可以看到根据前面的 `name`、`age` 再加上后面 order by 是根据 position 符合索引的排序条件，不需要再进行额外排序。 
另一种是查询条件中的顺序与索引不一致，也会导致 Extra 出现 Using filesort。
-- 查询顺序与索引不一致
explain select * from employees_explain where `name` = 'DiRenJie' order by age asc, `position` desc;
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ref  | idx_name_age_position | idx_name_age_position | 74      | const |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+---------------------------------------+
根据结果可以看到 order by 按照索引顺序进行查询，还是产生了 Using filesort 这是因为 order by 默认生序， position desc 变成降序，导致
与索引的排方式不同，从而造成了这样的结果。MySQL 8 支持这样的查询条件。
再来看一下下面这条sql
explain select * from employees_explain where `name` in ('DiRenJie', 'LiYuanFang') order by age, `position`;
虽然符合了联合索引的顺序，但是根据 `name` 取出的结果集， age `position` 并不是有序的，自然就会出现了 Using filesort。
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    2 |   100.00 | Using index condition; Using filesort |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+---------------------------------------+
-- 在数据量比较大的时候，即使使用了索引仍然不会使用到索引
explain select * from employees_explain where `name` > 'A' order by `name`;
这个表中有 10 w 条数据，以 A 开头的有 9w 多条，可能 MySQL 认为全表比索引成本低，所以使用了 Using filesort 进行排序。
输出结果：
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
| id | select_type | table             | partitions | type | possible_keys         | key  | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | idx_name_age_position | NULL | NULL    | NULL | 100085 |    50.00 | Using where; Using filesort |
+----+-------------+-------------------+------------+------+-----------------------+------+---------+------+--------+----------+-----------------------------+
当使用一个筛选数据结果集比较少的，还是会使用到索引排序的
-- 当筛选的数据量比较小的时候
explain select * from employees_explain where `name` > 'L' order by `name`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+
正对这种数据量大的结果集，我们可以通过覆盖索引进行优化
-- 覆盖索引优化这种筛选出的大的数据量
explain select `name` from employees_explain where `name` > 'A' order by `name`;
输出结果：
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
| id | select_type | table             | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | idx_name_age_position | idx_name_age_position | 74      | NULL | 50042 |   100.00 | Using where; Using index |
+----+-------------+-------------------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+--------------------------+
```
## Using filesort 文件排序原理详解
### filesort 文件排序方式
1. 单路排序：是一次性取出满足条件的所有字段，然后在 sort buffer 中进行排序；用 trace 工具中可以看到 sort_mode 信息里显示 `< sort_key`,
`additional_fields >` 或者 `< sort_key`, `packed_additional_fields >`；
2. 双路排序：(又叫回表排序模式)：首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完成后
需要再次取回其他需要的字段；用 trace 工具可以看到 sort_mode 信息里显示 `< sort_key, rowid`

MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节)的大小和需要查询的字段总大小来判断使用那种排序模式。
1. 如果字段的总长度小于 max_length_for_sort_data, 那么使用单路排序模式；
2. 如果字段的总长度大于 max_length_for_sort_data，那么使用双路排序模式；

可以自行测试一下：
```sql
默认 max_length_for_sort_data 为 1024 个字节
{
     /* filesort_priority_queue_optimization */,
    "filesort_summary": {  -- 文件排序信息
      "rows": 100000,  -- 预计扫描行数
      "examined_rows": 100000, -- 参与排序的行
      "number_of_tmp_files": 29, -- 使用临时文件的个数，这个值如果为 0 代表全部使用的 sort_buffer 内存排序，否则使用磁盘文件排序。
      "sort_buffer_size": 262056,
      "sort_mode": "<sort_key, packed_additional_fields>" -- 排序方式，小于 sort_key, 表示使用的是单路排序模式
    } /* filesort_summary */
}

可以手动设置 max_length_for_sort_data 长度，来看一下双路排模式:
set max_length_for_sort_data = 10; -- employees表所有字段长度总和肯定大于10字节
select * from employees_explain where name = 'DiRenJie' order by position;
select * from information_schema.OPTIMIZER_TRACE;
输出的结果：
{
    "filesort_summary": {
      "rows": 1,
      "examined_rows": 1,
      "number_of_tmp_files": 0,
      "sort_buffer_size": 262136,
      "sort_mode": "<sort_key, rowid>" -- 双路排序模式
    } /* filesort_summary */
  }
}

来分析一下执行过程：
我们先看单路排序的详细过程:
1. 从索引name找到第一个满足 name = ‘zhuge’ 条件的主键 id 
2. 根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中 
3. 从索引name找到下一个满足 name = ‘zhuge’ 条件的主键 id 
4. 重复步骤 2、3 直到不满足 name = ‘zhuge’
5. 对 sort_buffer 中的数据按照字段 position 进行排序
6. 返回结果给客户端
我们再看下双路排序的详细过程:
1. 从索引 name 找到第一个满足 name = ‘zhuge’ 的主键id
2. 根据主键 id 取出整行，把排序字段 position 和主键 id 这两个字段放到 sort buffer 中
3. 从索引 name 取下一个满足 name = ‘zhuge’ 记录的主键 id
4. 重复 3、4 直到不满足 name = ‘zhuge’
5. 对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序
6. 遍历排序好的 id 和字段 position，按照 id 的值回到原表中取出 所有字段的值返回给客户端
```
其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键 和需要排序的字段放到 sort buffer 
中进行排序，然后再通过主键回到原表查询需要的字段。 如果 MySQL 排序内存 sort_buffer 配置的比较小并且没有条件继续增加了，可以适当把 
max_length_for_sort_data 配置小点，让优化器选择使用双路排序算法，可以在sort_buffer 中一次排序更 多的行，只是需要再根据主键回到原表取数据。
如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器 优先选择全字段排序(单路排序)，把需要的
字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。
所以，MySQL通过 max_length_for_sort_data 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。
**注意**：如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增 大sort_buffer(默认1M)，mysql很多参数设
置都是做过优化的，不要轻易调整。

# 索引设计原则
1. 代码先行，索引后上：一般应该等到主体业务功能开发完毕，把涉及到该表相关sql都要拿出来分析之后再建立索引
2. 联合索引尽量覆盖条：比如可以设计一个或者两三个联合索引(尽量少建单值索引)，让每一个联合索引都尽量去包含sql语句里的 where、order by、
group by的字段，还要确保这些联合索引的字段顺序尽量满足sql查询的最左前缀原则；
3. 不要在小基数字段上建立索：一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能发挥出B+树快速二分查找的优势来。这里值
比较多的意思是可以理解为有多种类型。比如像性别，除了男、就女这两种值，那么该字段的基数就是2，给这种字段添加索引，没有办法进行二分查找，没有添加索引
的必要。
4. 长字符串我们可以采用前缀索引：尽量选择字段类型较小的列设计索引。因为这样占用磁盘空间较小，搜索性能会有所提高。实在买办法，看看是否可以
针对这个字段的前缀建立索引(一般取字段的前20个字符就差不多了)。但是使用前缀索引需要注意：当我们是使用前缀索引的时候，mySQL 会先根据索引列的前
20 个字符来搜索，然后再回到聚簇索引中提取出完整的字段来比较。而且 order by 条件是没办法使用索引的。 group by 也是一样的道理。
5. where与order by冲突时优先where：在where和order by出现索引设计冲突时，我们一般先满足 where 条件先筛选出一部分指定的数据，然后再进行排序，
这样相对来说排序成本会小很多。
## 分页查询优化
```sql
-- 根据自增且连续的主键排序的分页查询
explain select * from employees_explain limit 10000, 10;
mySQL 底层执行地时候不是从 10000 开始的，而是从 1 开始查到 10010，最终舍弃前面的数据，只保留 10 条数据。
-- 优化
explain select * from employees_explain where id > 90000 limit 10;
该 sql 就可以限定查询 id 从 90001 开始查询，筛选出 10 条数据，并且用到了主键索引。
输出结果：
+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
| id | select_type | table             | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | employees_explain | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 18754 |   100.00 | Using where |
+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
但是这种查询优化的条件比较苛刻，主键id必须自增且连续。当我们删除数据的时候，就会导致查询的结果集不一样了。
-- 根据非主键字段优化
explain select * from employees_explain order by name limit 90000, 5;
输出结果：
+----+-------------+-------------------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table             | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-------------------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | employees_explain | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 100085 |   100.00 | Using filesort |
+----+-------------+-------------------+------------+------+---------------+------+---------+------+--------+----------+----------------+
没有用到索引，并且还用了文件排序 Using filesort。查询到的结果：
-- 优化
explain select * from employees_explain e inner join (select id from employees_explain order by `name` limit 90000, 5) ed on e.id=ed.id;
输出结果：
+----+-------------+-------------------+------------+--------+---------------+-----------------------+---------+-------+-------+----------+-------------+
| id | select_type | table             | partitions | type   | possible_keys | key                   | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+-------------------+------------+--------+---------------+-----------------------+---------+-------+-------+----------+-------------+
|  1 | PRIMARY     | <derived2>        | NULL       | ALL    | NULL          | NULL                  | NULL    | NULL  | 90005 |   100.00 | NULL        |
|  1 | PRIMARY     | e                 | NULL       | eq_ref | PRIMARY       | PRIMARY               | 4       | ed.id |     1 |   100.00 | NULL        |
|  2 | DERIVED     | employees_explain | NULL       | index  | NULL          | idx_name_age_position | 140     | NULL  | 90005 |   100.00 | Using index |
+----+-------------+-------------------+------------+--------+---------------+-----------------------+---------+-------+-------+----------+-------------+
可以看到首先执行根据主键 id 进行过滤的数据，用到了索引，且解决了文件排序。接着用主键外层 sql 的主键 id 进行关联。此时的临时表 derived2 只有 5 条数据，即使全表扫描也不会带来什么影响。
```
